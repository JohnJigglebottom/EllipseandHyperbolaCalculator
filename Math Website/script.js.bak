function calculateConic() {
    const equationInput = document.getElementById('equationInput').value.trim();
    
    // Clear previous results
    document.getElementById('equationType').innerHTML = '';
    document.getElementById('center').innerHTML = '';
    document.getElementById('principalAxis').innerHTML = '';
    document.getElementById('vertices').innerHTML = '';
    document.getElementById('coVertices').innerHTML = '';
    document.getElementById('foci').i    }
       }
    
    // Adjust the viewing window to fit the conic section with padding
    const maxExtent = Math.max(Math.abs(a), Math.abs(b), Math.abs(c)) * 1.5;
    board.setBoundingBox([
        h - maxExtent,
        k + maxExtent,
        h + maxExtent,
        k - maxExtent
    ]);
}Adjust the viewing window to fit the conic section with padding
    const maxExtent = Math.max(Math.abs(a), Math.abs(b), Math.abs(c)) * 1.5;
    board.setBoundingBox([
        h - maxExtent,
        k + maxExtent,
        h + maxExtent,
        k - maxExtent
    ]); = '';
    document.getElementById('majorMinorAxes').innerHTML = '';
    document.getElementById('latusRectum').innerHTML = '';
    document.getElementById('transverseConjugateAxes').innerHTML = '';
    document.getElementById('fundamentalRectangle').innerHTML = '';
    document.getElementById('asymptotes').innerHTML = '';

    let type = '';
    let h = 0, k = 0, a_squared = 0, b_squared = 0;
    let isXMajor = true; // For ellipse: true if major axis is horizontal, false if vertical
                          // For hyperbola: true if transverse axis is horizontal, false if vertical

    // Regex patterns for different forms
    const termX = `(?:\\(x\\s*([+\\-])\\s*(\\d+)\\)|x)` // (x-h) or x
    const termY = `(?:\\(y\\s*([+\\-])\\s*(\\d+)\\)|y)` // (y-k) or y

    // Regex for Ellipse: (x-h)^2/a^2 + (y-k)^2/b^2 = 1 OR x^2/a^2 + y^2/b^2 = 1
    const ellipseRegex = new RegExp(`^\\s*${termX}\\^2\\s*\\/\\s*(\\d+)\\s*\\+\\s*${termY}\\^2\\s*\\/\\s*(\\d+)\\s*=\\s*1\\s*$`, 'i');
    
    // Regex for Hyperbola (X-major): (x-h)^2/a^2 - (y-k)^2/b^2 = 1 OR x^2/a^2 - y^2/b^2 = 1
    const hyperbolaXMajorRegex = new RegExp(`^\\s*${termX}\\^2\\s*\\/\\s*(\\d+)\\s*-\\s*${termY}\\^2\\s*\\/\\s*(\\d+)\\s*=\\s*1\\s*$`, 'i');

    // Regex for Hyperbola (Y-major): (y-k)^2/a^2 - (x-h)^2/b^2 = 1 OR y^2/a^2 - x^2/b^2 = 1
    const hyperbolaYMajorRegex = new RegExp(`^\\s*${termY}\\^2\\s*\\/\\s*(\\d+)\\s*-\\s*${termX}\\^2\\s*\\/\\s*(\\d+)\\s*=\\s*1\\s*$`, 'i');

    let match;

    if (match = equationInput.match(ellipseRegex)) {
        type = 'Ellipse';
        // Determine h
        if (match[1] === undefined) h = 0; // x^2 form
        else h = match[1] === '-' ? parseFloat(match[2]) : -parseFloat(match[2]);

        a_squared = parseFloat(match[3]); // denominator of x term
        
        // Determine k
        if (match[4] === undefined) k = 0; // y^2 form
        else k = match[4] === '-' ? parseFloat(match[5]) : -parseFloat(match[5]);

        b_squared = parseFloat(match[6]); // denominator of y term

        if (a_squared < b_squared) {
            // For ellipse, 'a' is always the larger semi-axis.
            // Swap a and b if b is larger, and flip orientation
            [a_squared, b_squared] = [b_squared, a_squared];
            isXMajor = false; // Major axis is vertical
        } else {
            isXMajor = true; // Major axis is horizontal
        }

    } else if (match = equationInput.match(hyperbolaXMajorRegex)) {
        type = 'Hyperbola';
        isXMajor = true;
        // Determine h
        if (match[1] === undefined) h = 0;
        else h = match[1] === '-' ? parseFloat(match[2]) : -parseFloat(match[2]);

        a_squared = parseFloat(match[3]); // a^2 is under the positive x term
        
        // Determine k
        if (match[4] === undefined) k = 0;
        else k = match[4] === '-' ? parseFloat(match[5]) : -parseFloat(match[5]);

        b_squared = parseFloat(match[6]); // b^2 is under the negative y term

    } else if (match = equationInput.match(hyperbolaYMajorRegex)) {
        type = 'Hyperbola';
        isXMajor = false; // Y-term is positive, so transverse axis is vertical
        // Determine k (for y term)
        if (match[1] === undefined) k = 0;
        else k = match[1] === '-' ? parseFloat(match[2]) : -parseFloat(match[2]);
        
        a_squared = parseFloat(match[3]); // a^2 is under the positive y term

        // Determine h (for x term)
        if (match[4] === undefined) h = 0;
        else h = match[4] === '-' ? parseFloat(match[5]) : -parseFloat(match[5]);

        b_squared = parseFloat(match[6]); // b^2 is under the negative x term
    } else {
        alert('Could not parse the equation. Please use a format like (x-h)^2/a^2 + (y-k)^2/b^2 = 1, x^2/a^2 + y^2/b^2 = 1, or their hyperbola equivalents.');
        return;
    }

    const a = Math.sqrt(a_squared);
    const b = Math.sqrt(b_squared);
    let c_squared, c;

    if (type === 'Ellipse') {
        c_squared = a_squared - b_squared;
    } else { // Hyperbola
        c_squared = a_squared + b_squared;
    }
    c = Math.sqrt(Math.abs(c_squared)); // Use Math.abs for c_squared in case of precision issues

    document.getElementById('equationType').innerHTML = `<strong>Equation Type:</strong> ${type}`;
    document.getElementById('center').innerHTML = `<strong>C = Center (h, k):</strong> (${h}, ${k})`;

    let principalAxisText = '';
    let verticesText = '';
    let coVerticesText = '';
    let fociText = '';
    let majorMinorAxesText = '';
    let latusRectumText = '';
    let transverseConjugateAxesText = '';
    let fundamentalRectangleText = '';
    let asymptotesText = '';

    if (type === 'Ellipse') {
        principalAxisText = isXMajor ? '<strong>Principal Axis:</strong> Horizontal (y = k = ' + k + ')' : '<strong>Principal Axis:</strong> Vertical (x = h = ' + h + ')';

        const V1 = isXMajor ? `(${h - a}, ${k})` : `(${h}, ${k - a})`;
        const V2 = isXMajor ? `(${h + a}, ${k})` : `(${h}, ${k + a})`;
        verticesText = `<strong>V1 = Vertex 1:</strong> (${(h - a).toFixed(2)}, ${(k).toFixed(2)})<br><strong>V2 = Vertex 2:</strong> (${(h + a).toFixed(2)}, ${(k).toFixed(2)})`;
        if (!isXMajor) { // Vertical Major Axis
            verticesText = `<strong>V1 = Vertex 1:</strong> (${(h).toFixed(2)}, ${(k - a).toFixed(2)})<br><strong>V2 = Vertex 2:</strong> (${(h).toFixed(2)}, ${(k + a).toFixed(2)})`;
        }

        const W1 = isXMajor ? `(${h}, ${k - b})` : `(${h - b}, ${k})`;
        const W2 = isXMajor ? `(${h}, ${k + b})` : `(${h + b}, ${k})`;
        coVerticesText = `<strong>W1 = Co-Vertex 1:</strong> (${(h).toFixed(2)}, ${(k - b).toFixed(2)})<br><strong>W2 = Co-Vertex 2:</strong> (${(h).toFixed(2)}, ${(k + b).toFixed(2)})`;
        if (!isXMajor) { // Vertical Major Axis
            coVerticesText = `<strong>W1 = Co-Vertex 1:</strong> (${(h - b).toFixed(2)}, ${(k).toFixed(2)})<br><strong>W2 = Co-Vertex 2:</strong> (${(h + b).toFixed(2)}, ${(k).toFixed(2)})`;
        }
        
        const F1 = isXMajor ? `(${h - c}, ${k})` : `(${h}, ${k - c})`;
        const F2 = isXMajor ? `(${h + c}, ${k})` : `(${h}, ${k + c})`;
        fociText = `<strong>F1 = Focus 1:</strong> (${(h - c).toFixed(2)}, ${(k).toFixed(2)})<br><strong>F2 = Focus 2:</strong> (${(h + c).toFixed(2)}, ${(k).toFixed(2)})`;
        if (!isXMajor) { // Vertical Major Axis
            fociText = `<strong>F1 = Focus 1:</strong> (${(h).toFixed(2)}, ${(k - c).toFixed(2)})<br><strong>F2 = Focus 2:</strong> (${(h).toFixed(2)}, ${(k + c).toFixed(2)})`;
        }

        majorMinorAxesText = `<strong>Major Axis Length:</strong> ${2 * a}<br><strong>Minor Axis Length:</strong> ${2 * b}`;
        
        const latusRectumLength = (2 * b_squared) / a;
        let lr1_x, lr1_y, lr2_x, lr2_y, lr3_x, lr3_y, lr4_x, lr4_y;

        if (isXMajor) {
            lr1_x = h - c; lr1_y = k + latusRectumLength / 2;
            lr2_x = h - c; lr2_y = k - latusRectumLength / 2;
            lr3_x = h + c; lr3_y = k + latusRectumLength / 2;
            lr4_x = h + c; lr4_y = k - latusRectumLength / 2;
        } else { // Y-Major
            lr1_x = h + latusRectumLength / 2; lr1_y = k - c;
            lr2_x = h - latusRectumLength / 2; lr2_y = k - c;
            lr3_x = h + latusRectumLength / 2; lr3_y = k + c;
            lr4_x = h - latusRectumLength / 2; lr4_y = k + c;
        }

        latusRectumText = `<strong>Latus Rectum Length:</strong> ${latusRectumLength.toFixed(2)}<br>` +
                          `<strong>LR1:</strong> (${lr1_x.toFixed(2)}, ${lr1_y.toFixed(2)})<br>` +
                          `<strong>LR2:</strong> (${lr2_x.toFixed(2)}, ${lr2_y.toFixed(2)})<br>` +
                          `<strong>LR3:</strong> (${lr3_x.toFixed(2)}, ${lr3_y.toFixed(2)})<br>` +
                          `<strong>LR4:</strong> (${lr4_x.toFixed(2)}, ${lr4_y.toFixed(2)})`;

    } else { // Hyperbola
        principalAxisText = isXMajor ? '<strong>Transverse Axis:</strong> Horizontal (y = k = ' + k + ')' : '<strong>Transverse Axis:</strong> Vertical (x = h = ' + h + ')';

        const V1 = isXMajor ? `(${h - a}, ${k})` : `(${h}, ${k - a})`;
        const V2 = isXMajor ? `(${h + a}, ${k})` : `(${h}, ${k + a})`;
        verticesText = `<strong>V1 = Vertex 1:</strong> (${(h - a).toFixed(2)}, ${(k).toFixed(2)})<br><strong>V2 = Vertex 2:</strong> (${(h + a).toFixed(2)}, ${(k).toFixed(2)})`;
        if (!isXMajor) { // Vertical Transverse Axis
            verticesText = `<strong>V1 = Vertex 1:</strong> (${(h).toFixed(2)}, ${(k - a).toFixed(2)})<br><strong>V2 = Vertex 2:</strong> (${(h).toFixed(2)}, ${(k + a).toFixed(2)})`;
        }

        // Co-vertices are for the conjugate axis
        const W1 = isXMajor ? `(${h}, ${k - b})` : `(${h - b}, ${k})`;
        const W2 = isXMajor ? `(${h}, ${k + b})` : `(${h + b}, ${k})`;
        coVerticesText = `<strong>W1 = Co-Vertex 1:</strong> (${(h).toFixed(2)}, ${(k - b).toFixed(2)})<br><strong>W2 = Co-Vertex 2:</strong> (${(h).toFixed(2)}, ${(k + b).toFixed(2)})`;
        if (!isXMajor) { // Vertical Transverse Axis
            coVerticesText = `<strong>W1 = Co-Vertex 1:</strong> (${(h - b).toFixed(2)}, ${(k).toFixed(2)})<br><strong>W2 = Co-Vertex 2:</strong> (${(h + b).toFixed(2)}, ${(k).toFixed(2)})`;
        }

        const F1 = isXMajor ? `(${h - c}, ${k})` : `(${h}, ${k - c})`;
        const F2 = isXMajor ? `(${h + c}, ${k})` : `(${h}, ${k + c})`;
        fociText = `<strong>F1 = Focus 1:</strong> (${(h - c).toFixed(2)}, ${(k).toFixed(2)})<br><strong>F2 = Focus 2:</strong> (${(h + c).toFixed(2)}, ${(k).toFixed(2)})`;
        if (!isXMajor) { // Vertical Transverse Axis
            fociText = `<strong>F1 = Focus 1:</strong> (${(h).toFixed(2)}, ${(k - c).toFixed(2)})<br><strong>F2 = Focus 2:</strong> (${(h).toFixed(2)}, ${(k + c).toFixed(2)})`;
        }

        transverseConjugateAxesText = `<strong>Transverse Axis Length:</strong> ${2 * a}<br><strong>Conjugate Axis Length:</strong> ${2 * b}`;

        const latusRectumLength = (2 * b_squared) / a;
        let lr1_x, lr1_y, lr2_x, lr2_y, lr3_x, lr3_y, lr4_x, lr4_y;

        if (isXMajor) {
            lr1_x = h - c; lr1_y = k + latusRectumLength / 2;
            lr2_x = h - c; lr2_y = k - latusRectumLength / 2;
            lr3_x = h + c; lr3_y = k + latusRectumLength / 2;
            lr4_x = h + c; lr4_y = k - latusRectumLength / 2;
        } else { // Y-Major
            lr1_x = h + latusRectumLength / 2; lr1_y = k - c;
            lr2_x = h - latusRectumLength / 2; lr2_y = k - c;
            lr3_x = h + latusRectumLength / 2; lr3_y = k + c;
            lr4_x = h - latusRectumLength / 2; lr4_y = k + c;
        }

        latusRectumText = `<strong>Latus Rectum Length:</strong> ${latusRectumLength.toFixed(2)}<br>` +
                          `<strong>LR1:</strong> (${lr1_x.toFixed(2)}, ${lr1_y.toFixed(2)})<br>` +
                          `<strong>LR2:</strong> (${lr2_x.toFixed(2)}, ${lr2_y.toFixed(2)})<br>` +
                          `<strong>LR3:</strong> (${lr3_x.toFixed(2)}, ${lr3_y.toFixed(2)})<br>` +
                          `<strong>LR4:</strong> (${lr4_x.toFixed(2)}, ${lr4_y.toFixed(2)})`;

        // Fundamental Rectangle
        // For hyperbola centered at (h,k) with transverse axis along x-axis
        const rectTopLeft = `(${h - a}, ${k + b})`;
        const rectTopRight = `(${h + a}, ${k + b})`;
        const rectBottomLeft = `(${h - a}, ${k - b})`;
        const rectBottomRight = `(${h + a}, ${k - b})`;
        fundamentalRectangleText = `<strong>Fundamental Rectangle Vertices:</strong><br>` +
                                   `Top-Left: (${(h - a).toFixed(2)}, ${(k + b).toFixed(2)})<br>Top-Right: (${(h + a).toFixed(2)}, ${(k + b).toFixed(2)})<br>` +
                                   `Bottom-Left: (${(h - a).toFixed(2)}, ${(k - b).toFixed(2)})<br>Bottom-Right: (${(h + a).toFixed(2)}, ${(k - b).toFixed(2)})`;


        // Asymptotes (y - k = +/- (b/a)(x - h) for x-major, y - k = +/- (a/b)(x - h) for y-major)
        asymptotesText = `<strong>Asymptotes:</strong><br>`;
        if (isXMajor) {
            const slope = b / a;
            asymptotesText += `y - ${k.toFixed(2)} = ${slope.toFixed(2)}(x - ${h.toFixed(2)})<br>`;
            asymptotesText += `y - ${k.toFixed(2)} = -${slope.toFixed(2)}(x - ${h.toFixed(2)})`;
        } else { // Y-Major, so a is with y, b with x
            const slope = a / b;
            asymptotesText += `y - ${k.toFixed(2)} = ${slope.toFixed(2)}(x - ${h.toFixed(2)})<br>`;
            asymptotesText += `y - ${k.toFixed(2)} = -${slope.toFixed(2)}(x - ${h.toFixed(2)})`;
        }
    }

    document.getElementById('principalAxis').innerHTML = principalAxisText;
    document.getElementById('vertices').innerHTML = verticesText;
    document.getElementById('coVertices').innerHTML = coVerticesText;
    document.getElementById('foci').innerHTML = fociText;
    document.getElementById('majorMinorAxes').innerHTML = majorMinorAxesText;
    document.getElementById('latusRectum').innerHTML = latusRectumText;
    document.getElementById('transverseConjugateAxes').innerHTML = transverseConjugateAxesText;
    document.getElementById('fundamentalRectangle').innerHTML = fundamentalRectangleText;
    document.getElementById('asymptotes').innerHTML = asymptotesText;

    // Call the basic graphing function
    drawConic(type, h, k, a, b, isXMajor);
}

function drawConic(type, h, k, a, b, isXMajor) {
    // Clear the board and reinitialize
    JXG.JSXGraph.freeBoard(board);
    board = JXG.JSXGraph.initBoard('jxgbox', {
        boundingbox: [-10, 10, 10, -10],
        axis: true,
        showCopyright: false,
        defaultAxes: {
            x: { name: 'x', label: { position: 'rt', offset: [10, -15] } },
            y: { name: 'y', label: { position: 'rt', offset: [15, 10] } }
        }
    });

    // Calculate focal points
    const c = Math.sqrt(type === 'Ellipse' ? a * a - b * b : a * a + b * b);
    
    // Plot center point (green)
    board.create('point', [h, k], {
        name: `C(${h}, ${k})`,
        size: 4,
        face: 'circle',
        color: 'green',
        fixed: true
    });

    // Plot vertices (red)
    board.create('point', 
        isXMajor ? [h - a, k] : [h, k - a], {
        name: 'V₁',
        size: 4,
        face: 'cross',
        color: 'red',
        fixed: true
    });
    board.create('point',
        isXMajor ? [h + a, k] : [h, k + a], {
        name: 'V₂',
        size: 4,
        face: 'cross',
        color: 'red',
        fixed: true
    });

    // Plot co-vertices (orange)
    board.create('point',
        isXMajor ? [h, k - b] : [h - b, k], {
        name: 'W₁',
        size: 4,
        face: 'diamond',
        color: 'orange',
        fixed: true
    });
    board.create('point',
        isXMajor ? [h, k + b] : [h + b, k], {
        name: 'W₂',
        size: 4,
        face: 'diamond',
        color: 'orange',
        fixed: true
    });

    // Plot foci (purple)
    board.create('point',
        isXMajor ? [h - c, k] : [h, k - c], {
        name: 'F₁',
        size: 4,
        face: 'plus',
        color: 'purple',
        fixed: true
    });
    board.create('point',
        isXMajor ? [h + c, k] : [h, k + c], {
        name: 'F₂',
        size: 4,
        face: 'plus',
        color: 'purple',
        fixed: true
    });

    // Plot the conic section
    if (type === 'Ellipse') {
        // Plot ellipse using implicit curve
        board.create('conic', [
            [1/(a*a), 0, 1/(b*b), -2*h/(a*a), -2*k/(b*b), 
            h*h/(a*a) + k*k/(b*b) - 1]], 
            {
                strokeColor: 'blue',
                strokeWidth: 2
            }
        );

        // Plot latus rectum points
        const latusRectumLength = (2 * b * b) / a;
        board.create('point',
            isXMajor ? [h - c, k + latusRectumLength/2] : [h + latusRectumLength/2, k - c],
            {name: 'LR₁', size: 3, face: 'square', color: 'blue', fixed: true}
        );
        board.create('point',
            isXMajor ? [h - c, k - latusRectumLength/2] : [h - latusRectumLength/2, k - c],
            {name: 'LR₂', size: 3, face: 'square', color: 'blue', fixed: true}
        );
        board.create('point',
            isXMajor ? [h + c, k + latusRectumLength/2] : [h + latusRectumLength/2, k + c],
            {name: 'LR₃', size: 3, face: 'square', color: 'blue', fixed: true}
        );
        board.create('point',
            isXMajor ? [h + c, k - latusRectumLength/2] : [h - latusRectumLength/2, k + c],
            {name: 'LR₄', size: 3, face: 'square', color: 'blue', fixed: true}
        );
    } else { // Hyperbola
        // Plot hyperbola using implicit curve
        board.create('conic', [
            [1/(a*a), 0, -1/(b*b), -2*h/(a*a), -2*k/(b*b),
            h*h/(a*a) - k*k/(b*b) - 1]],
            {
                strokeColor: 'blue',
                strokeWidth: 2
            }
        );

        // Plot asymptotes
        const slope = isXMajor ? b/a : a/b;
        board.create('line', [
            [h, k], [h + 1, k + slope]], 
            {dash: 2, strokeColor: 'gray'}
        );
        board.create('line', [
            [h, k], [h + 1, k - slope]], 
            {dash: 2, strokeColor: 'gray'}
        );

        // Plot latus rectum points
        const latusRectumLength = (2 * b * b) / a;
        board.create('point',
            isXMajor ? [h - c, k + latusRectumLength/2] : [h + latusRectumLength/2, k - c],
            {name: 'LR₁', size: 3, face: 'square', color: 'blue', fixed: true}
        );
        board.create('point',
            isXMajor ? [h - c, k - latusRectumLength/2] : [h - latusRectumLength/2, k - c],
            {name: 'LR₂', size: 3, face: 'square', color: 'blue', fixed: true}
        );
        board.create('point',
            isXMajor ? [h + c, k + latusRectumLength/2] : [h + latusRectumLength/2, k + c],
            {name: 'LR₃', size: 3, face: 'square', color: 'blue', fixed: true}
        );
        board.create('point',
            isXMajor ? [h + c, k - latusRectumLength/2] : [h - latusRectumLength/2, k + c],
            {name: 'LR₄', size: 3, face: 'square', color: 'blue', fixed: true}
        );

        if (isXMajor) {
            // Hyperbola x^2/a^2 - y^2/b^2 = 1 => y = +/- b * sqrt((x^2/a^2) - 1)
            // Draw right branch
            ctx.moveTo(a * scale, 0);
            for (let i = 0; i <= numPoints; i++) {
                const x_val = a + i * (maxCoord - a) / numPoints;
                const y_val = b * Math.sqrt((x_val * x_val / (a * a)) - 1);
                if (!isNaN(y_val)) {
                    ctx.lineTo(x_val * scale, y_val * scale);
                }
            }
            ctx.moveTo(a * scale, 0); // Reset for lower half
            for (let i = 0; i <= numPoints; i++) {
                const x_val = a + i * (maxCoord - a) / numPoints;
                const y_val = -b * Math.sqrt((x_val * x_val / (a * a)) - 1);
                if (!isNaN(y_val)) {
                    ctx.lineTo(x_val * scale, y_val * scale);
                }
            }

            // Draw left branch
            ctx.moveTo(-a * scale, 0);
            for (let i = 0; i <= numPoints; i++) {
                const x_val = -a - i * (maxCoord - a) / numPoints;
                const y_val = b * Math.sqrt((x_val * x_val / (a * a)) - 1);
                if (!isNaN(y_val)) {
                    ctx.lineTo(x_val * scale, y_val * scale);
                }
            }
            ctx.moveTo(-a * scale, 0); // Reset for lower half
            for (let i = 0; i <= numPoints; i++) {
                const x_val = -a - i * (maxCoord - a) / numPoints;
                const y_val = -b * Math.sqrt((x_val * x_val / (a * a)) - 1);
                if (!isNaN(y_val)) {
                    ctx.lineTo(x_val * scale, y_val * scale);
                }
            }
        } else { // Y-Major Hyperbola
            // Hyperbola y^2/a^2 - x^2/b^2 = 1 => x = +/- b * sqrt((y^2/a^2) - 1)
            // Draw upper branch
            ctx.moveTo(0, a * scale);
            for (let i = 0; i <= numPoints; i++) {
                const y_val = a + i * (maxCoord - a) / numPoints;
                const x_val = b * Math.sqrt((y_val * y_val / (a * a)) - 1);
                if (!isNaN(x_val)) {
                    ctx.lineTo(x_val * scale, y_val * scale);
                }
            }
            ctx.moveTo(0, a * scale); // Reset for left half
            for (let i = 0; i <= numPoints; i++) {
                const y_val = a + i * (maxCoord - a) / numPoints;
                const x_val = -b * Math.sqrt((y_val * y_val / (a * a)) - 1);
                if (!isNaN(x_val)) {
                    ctx.lineTo(x_val * scale, y_val * scale);
                }
            }

            // Draw lower branch
            ctx.moveTo(0, -a * scale);
            for (let i = 0; i <= numPoints; i++) {
                const y_val = -a - i * (maxCoord - a) / numPoints;
                const x_val = b * Math.sqrt((y_val * y_val / (a * a)) - 1);
                if (!isNaN(x_val)) {
                    ctx.lineTo(x_val * scale, y_val * scale);
                }
            }
            ctx.moveTo(0, -a * scale); // Reset for left half
            for (let i = 0; i <= numPoints; i++) {
                const y_val = -a - i * (maxCoord - a) / numPoints;
                const x_val = -b * Math.sqrt((y_val * y_val / (a * a)) - 1);
                if (!isNaN(x_val)) {
                    ctx.lineTo(x_val * scale, y_val * scale);
                }
            }
        }
    }
    ctx.stroke();
    ctx.restore();
}